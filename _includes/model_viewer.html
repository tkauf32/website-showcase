<div class="viewer-3d">
  <canvas id="glbCanvas-{{ include.src | slugify }}"></canvas>
</div>

<script type="module">
  // Use CDN ESM modules (no bundler needed)
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { DRACOLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js";
  import { RGBELoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/RGBELoader.js";

  const src = "{{ include.src | relative_url }}";
  const canvas = document.getElementById("glbCanvas-{{ include.src | slugify }}");

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.setClearColor(0xFFFFFFF, 1);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  camera.position.set(1.2, 0.9, 1.6);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.autoRotate = true;         // spin by default
  controls.autoRotateSpeed = 1.2;     // tweak to taste

  let userInteracted = false;
  const pauseAuto = () => { userInteracted = true; controls.autoRotate = false; };
  const resumeAuto = () => { if (!userInteracted) controls.autoRotate = true; };

  // Listen for any pointer interaction on the canvas
  ['pointerdown','wheel','keydown','touchstart'].forEach(evt =>
    canvas.addEventListener(evt, pauseAuto, { passive: true })
  );

  // Optional: resume after some idle time (e.g., 6s)
  let idleTimer;
  const resetIdleTimer = () => {
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => { userInteracted = false; controls.autoRotate = true; }, 6000);
  };
  ['pointerup','mouseleave','touchend'].forEach(evt =>
    canvas.addEventListener(evt, resetIdleTimer, { passive: true })
  );

  // Lighting (simple, no HDR to avoid CORS)
  scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.7);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x2a2a3a, 0.65);
  scene.add(hemi);

  dir.position.set(2.5, 4.0, 2.0);
  scene.add(dir);

  // Helps lift shadows without blowing highlights
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));
  // Optional: globally reduce specular/reflection intensity if models look too glossy
  scene.traverse(obj => {
    if (obj.isMesh && obj.material && obj.material.isMeshStandardMaterial) {
      obj.material.roughness = Math.min(1.0, (obj.material.roughness ?? 0.5) + 0.15);
      // obj.material.envMapIntensity = 0.5; // enable if you add an HDR environment later
    }
  });

  new RGBELoader()
    .load("{{ '/assets/env/studio_small_03_1k.hdr' | relative_url }}", (hdr) => {
      hdr.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = hdr;
    });
  dir.position.set(3, 5, 2);
  scene.add(dir);

  // GLTF + DRACO
  const loader = new GLTFLoader();
  const draco = new DRACOLoader();
  // Point to Draco decoder files hosted on unpkg (draco_decoder.wasm / .js)
  draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
  loader.setDRACOLoader(draco);

  loader.load(
    src,
    (gltf) => {
      const root = gltf.scene || gltf.scenes?.[0];
      const yawDeg = {{ include.rotation_y | default: 0 }};
      if (yawDeg) {
        root.rotation.y = yawDeg * Math.PI / 180;
      }
      if (!root) throw new Error("GLB loaded but no scene found");
      scene.add(root);

      // Auto-center & fit
      const box = new THREE.Box3().setFromObject(root);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      const length = size.length();
      camera.near = length / 100;
      camera.far = length * 10;
      camera.updateProjectionMatrix();
      camera.position.set(length * 0.6, length * 0.45, length * 0.9);
    },
    undefined,
    (err) => {
      console.error("GLB load error:", err);
      const msg = document.createElement("div");
      msg.textContent = "Failed to load 3D model.";
      msg.style.cssText = "padding:8px;color:#b00;font:14px/1.4 system-ui;";
      canvas.parentElement.appendChild(msg);
    }
  );

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height || 420;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
  new ResizeObserver(resize).observe(canvas.parentElement);
  resize(); animate();
</script>
